/*
 * Copyright (C) 2018-2021  CZ.NIC, z. s. p. o.
 *
 * This file is part of FRED.
 *
 * FRED is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * FRED is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with FRED.  If not, see <https://www.gnu.org/licenses/>.
 */
/**
 *  @file
 *  domain info
 */

#ifndef INFO_DOMAIN_HH_E4C6FC6930714E419B82E94BD9F47DC6
#define INFO_DOMAIN_HH_E4C6FC6930714E419B82E94BD9F47DC6

#include "libfred/opcontext.hh"
#include "libfred/opexception.hh"
#include "libfred/registrable_object/domain/domain_uuid.hh"
#include "libfred/registrable_object/domain/info_domain_output.hh"

#include "util/optional_value.hh"
#include "util/printable.hh"

#include <boost/date_time/posix_time/ptime.hpp>

#include <string>
#include <vector>

namespace LibFred {

/**
 * Domain info by fully qualified domain name.
 * Domain fully qualified name to get info about is set via constructor.
 * It's executed by @ref exec method with database connection supplied in @ref OperationContext parameter.
 */
class InfoDomainByFqdn : public Util::Printable<InfoDomainByFqdn>
{
public:
    DECLARE_EXCEPTION_DATA(unknown_fqdn, std::string);/**< exception members for unknown fully qualified domain name generated by macro @ref DECLARE_EXCEPTION_DATA*/
    struct Exception
    : virtual LibFred::OperationException
    , ExceptionData_unknown_fqdn<Exception>
    {};

    /**
     * Info domain constructor with mandatory parameter.
     * @param fqdn sets fully qualified domain name into @ref fqdn_ attribute
     */
    InfoDomainByFqdn(const std::string& fqdn);

    /**
     * Sets lock for update.
     * Default, if not set, is lock for share.
     * Sets true to lock flag in @ref lock_ attribute
     * @return operation instance reference to allow method chaining
     */
    InfoDomainByFqdn& set_lock();

    /**
     * Executes getting info about the domain.
     * @param ctx contains reference to database and logging interface
     * @param local_timestamp_pg_time_zone_name is postgresql time zone name of the returned data
     * @return info data about the domain
     * @throws Exception in case of wrong input data or other predictable and superable failure.
     * @throws InternalError otherwise
     */
    InfoDomainOutput exec(const OperationContext& ctx, const std::string& local_timestamp_pg_time_zone_name = "Europe/Prague");

    /**
     * Dumps state of the instance into the string
     * @return string with description of the instance state
     */
    std::string to_string()const;
private:
    const std::string fqdn_;/**< fully qualified domain name */
    bool lock_;/**< if set to true lock object_registry row for update, if set to false lock for share */
};

/**
 * Domain info by id.
 * Domain id to get info about the domain is set via constructor.
 * It's executed by @ref exec method with database connection supplied in @ref OperationContext parameter.
 */
class InfoDomainById : public Util::Printable<InfoDomainById>
{
public:
    DECLARE_EXCEPTION_DATA(unknown_object_id, unsigned long long);/**< exception members for unknown object id of the domain generated by macro @ref DECLARE_EXCEPTION_DATA*/
    struct Exception
    : virtual LibFred::OperationException
    , ExceptionData_unknown_object_id<Exception>
    {};

    /**
     * Info domain constructor with mandatory parameter.
     * @param id sets object id of the domain into @ref id_ attribute
     */
    explicit InfoDomainById(unsigned long long id);

    /**
     * Sets lock for update.
     * Default, if not set, is lock for share.
     * Sets true to lock flag in @ref lock_ attribute
     * @return operation instance reference to allow method chaining
     */
    InfoDomainById& set_lock();

    /**
     * Executes getting info about the domain.
     * @param ctx contains reference to database and logging interface
     * @param local_timestamp_pg_time_zone_name is postgresql time zone name of the returned data
     * @return info data about the domain
     * @throws Exception in case of wrong input data or other predictable and superable failure.
     * @throws InternalError otherwise
     */
    InfoDomainOutput exec(const OperationContext& ctx, const std::string& local_timestamp_pg_time_zone_name = "Europe/Prague");

    /**
     * Dumps state of the instance into the string
     * @return string with description of the instance state
     */
    std::string to_string()const;
private:
    const unsigned long long id_;/**< object id of the domain */
    bool lock_;/**< if set to true lock object_registry row for update, if set to false lock for share */
};

/**
 * Domain info by uuid.
 * Domain uuid to get info about the domain is set via constructor.
 * It's executed by @ref exec method.
*/
class InfoDomainByUuid : public Util::Printable<InfoDomainByUuid>
{
public:
    DECLARE_EXCEPTION_DATA(unknown_domain_uuid, RegistrableObject::Domain::DomainUuid::UnderlyingType);
    struct Exception
        : virtual LibFred::OperationException,
          ExceptionData_unknown_domain_uuid<Exception>
    { };

    /**
     * Info domain constructor with mandatory parameter.
     * @param id sets object id of the domain into @ref id_ attribute
     */
    explicit InfoDomainByUuid(const RegistrableObject::Domain::DomainUuid& uuid);

    /**
     * Executes getting info about the domain. Time zone name of the returned data is UTC.
     * @tparam lock type of database locking
     * @param ctx contains reference to database and logging interface
     * @return info data about the domain
     * @throws Exception in case of wrong input data or other predictable and superable failure.
     * @throws InternalError otherwise
     */
    template <DbLock lock>
    InfoDomainOutput exec(const OperationContextUsing<lock>& ctx);

    /**
     * Dumps state of the instance into the string
     * @return string with description of the instance state
     */
    std::string to_string()const;
private:
    const RegistrableObject::Domain::DomainUuid uuid_;
};

/**
 * Domain info by history uuid.
 * Domain history uuid to get info about the domain is set via constructor.
 * It's executed by @ref exec method
*/
class InfoDomainByHistoryUuid : public Util::Printable<InfoDomainByHistoryUuid>
{
public:
    DECLARE_EXCEPTION_DATA(unknown_domain_history_uuid, RegistrableObject::Domain::DomainHistoryUuid::UnderlyingType);
    struct Exception
        : virtual LibFred::OperationException,
          ExceptionData_unknown_domain_history_uuid<Exception>
    { };

    /**
     * Info domain constructor with mandatory parameter.
     * @param id sets object id of the domain into @ref id_ attribute
     */
    explicit InfoDomainByHistoryUuid(const RegistrableObject::Domain::DomainHistoryUuid& history_uuid);

    /**
     * Executes getting info about the domain. Time zone name of the returned data is UTC.
     * @tparam lock type of database locking
     * @param ctx contains reference to database and logging interface
     * @return info data about the domain
     * @throws Exception in case of wrong input data or other predictable and superable failure.
     * @throws InternalError otherwise
     */
    template <DbLock lock>
    InfoDomainOutput exec(const OperationContextUsing<lock>& ctx);

    /**
     * Dumps state of the instance into the string
     * @return string with description of the instance state
     */
    std::string to_string()const;
private:
    const RegistrableObject::Domain::DomainHistoryUuid history_uuid_;
};

/**
 * Domain history info.
 * Output data are arranged in descending order by historyid.
 * Domain registry object identifier to get history info about the domain is set via constructor.
 * It's executed by @ref exec method with database connection supplied in @ref OperationContext parameter.
 */
class InfoDomainHistoryByRoid : public Util::Printable<InfoDomainHistoryByRoid>
{
public:
    /**
     * Info domain history constructor with mandatory parameter.
     * @param roid sets registry object identifier of the domain into @ref roid_ attribute
     */
    InfoDomainHistoryByRoid(const std::string& roid);

    /**
     * Sets lock for update.
     * Default, if not set, is lock for share.
     * Sets true to lock flag in @ref lock_ attribute
     * @return operation instance reference to allow method chaining
     */
    InfoDomainHistoryByRoid& set_lock();

    /**
     * Executes getting history info about the domain.
     * @param ctx contains reference to database and logging interface
     * @param local_timestamp_pg_time_zone_name is postgresql time zone name of the returned data
     * @return history info data about the domain in descending order by historyid
     * @throws Exception in case of wrong input data or other predictable and superable failure.
     */
    std::vector<InfoDomainOutput> exec(const OperationContext& ctx, const std::string& local_timestamp_pg_time_zone_name = "Europe/Prague");

    /**
     * Dumps state of the instance into the string
     * @return string with description of the instance state
     */
    std::string to_string()const;
private:
    const std::string roid_;/**< registry object identifier of the domain */
    bool lock_;/**< if set to true lock object_registry row for update, if set to false lock for share */
};

/**
 * Domain info by id including history.
 * Output data are arranged in descending order by historyid.
 * Domain id to get info about the domain is set via constructor.
 * It's executed by @ref exec method with database connection supplied in @ref OperationContext parameter.
 */
class InfoDomainHistoryById : public Util::Printable<InfoDomainHistoryById>
{
public:
    /**
     * Info domain history constructor with mandatory parameter.
     * @param id sets object id of the domain into @ref id_ attribute
     */
    explicit InfoDomainHistoryById(unsigned long long id);

    /**
     * Sets lock for update.
     * Default, if not set, is lock for share.
     * Sets true to lock flag in @ref lock_ attribute
     * @return operation instance reference to allow method chaining
     */
    InfoDomainHistoryById& set_lock();

    /**
     * Executes getting history info about the domain.
     * @param ctx contains reference to database and logging interface
     * @param local_timestamp_pg_time_zone_name is postgresql time zone name of the returned data
     * @return history info data about the domain in descending order by historyid
     * @throws Exception in case of wrong input data or other predictable and superable failure.
     */
    std::vector<InfoDomainOutput> exec(const OperationContext& ctx, const std::string& local_timestamp_pg_time_zone_name = "Europe/Prague");

    /**
     * Dumps state of the instance into the string
     * @return string with description of the instance state
     */
    std::string to_string()const;
private:
    const unsigned long long id_;/**< object id of the domain */
    bool lock_;/**< if set to true lock object_registry row for update, if set to false lock for share */
};

/**
 * Domain info by historyid.
 * Domain historyid to get info about the domain is set via constructor.
 * It's executed by @ref exec method with database connection supplied in @ref OperationContext parameter.
 */
class InfoDomainHistoryByHistoryid : public Util::Printable<InfoDomainHistoryByHistoryid>
{
public:
    DECLARE_EXCEPTION_DATA(unknown_object_historyid, unsigned long long);/**< exception members for unknown object historyid of the domain generated by macro @ref DECLARE_EXCEPTION_DATA*/
    struct Exception
    : virtual LibFred::OperationException
    , ExceptionData_unknown_object_historyid<Exception>
    {};

    /**
     * Info domain history constructor with mandatory parameter.
     * @param historyid sets object historyid of the domain into @ref historyid_ attribute
     */
    explicit InfoDomainHistoryByHistoryid(unsigned long long historyid);

    /**
     * Sets lock for update.
     * Default, if not set, is lock for share.
     * Sets true to lock flag in @ref lock_ attribute
     * @return operation instance reference to allow method chaining
     */
    InfoDomainHistoryByHistoryid& set_lock();

    /**
     * Executes getting history info about the domain.
     * @param ctx contains reference to database and logging interface
     * @param local_timestamp_pg_time_zone_name is postgresql time zone name of the returned data
     * @return history info data about the domain
     * @throws Exception in case of wrong input data or other predictable and superable failure.
     * @throws InternalError otherwise
     */
    InfoDomainOutput exec(const OperationContext& ctx, const std::string& local_timestamp_pg_time_zone_name = "Europe/Prague");

    /**
     * Dumps state of the instance into the string
     * @return string with description of the instance state
     */
    std::string to_string()const;
private:
    const unsigned long long historyid_;/**< history id of the domain */
    bool lock_;/**< if set to true lock object_registry row for update, if set to false lock for share */
};

/**
 * Domains info by registrant handle.
 * Registrant handle of domains to get info about is set via constructor.
 * It's executed by @ref exec method with database connection supplied in @ref OperationContext parameter.
 */
class InfoDomainByRegistrantHandle : public Util::Printable<InfoDomainByRegistrantHandle>
{
public:
    /**
     * Info domain constructor with mandatory parameter.
     * @param registrant_handle sets registrant handle into @ref registrant_handle_ attribute
     */
    explicit InfoDomainByRegistrantHandle(const std::string& registrant_handle);

    /**
     * Sets lock for update.
     * Default, if not set, is lock for share.
     * Sets true to lock flag in @ref lock_ attribute
     * @return operation instance reference to allow method chaining
     */
    InfoDomainByRegistrantHandle& set_lock();

    /**
     * Sets limit on number of returned InfoDomainOutput structures.
     * Filter query ordered by domainid.
     * If not set, there is no limit.
     * Sets  @ref limit_ attribute
     * @return operation instance reference to allow method chaining
     */
    InfoDomainByRegistrantHandle& set_limit(unsigned long long limit);

    /**
     * Executes getting info about domains.
     * @param ctx contains reference to database and logging interface
     * @param local_timestamp_pg_time_zone_name is postgresql time zone name of the returned data
     * @return info data about domains
     */
    std::vector<InfoDomainOutput> exec(const OperationContext& ctx, const std::string& local_timestamp_pg_time_zone_name = "Europe/Prague");

    /**
     * Dumps state of the instance into the string
     * @return string with description of the instance state
     */
    std::string to_string()const;
private:
    const std::string registrant_handle_;/**< registrant handle */
    bool lock_;/**< if set to true lock object_registry row for update, if set to false lock for share */
    Optional<unsigned long long> limit_;/**< max number of returned InfoDomainOutput structures */
};

/**
 * Domain info by administrator contact handle.
 * Administrator contact handle of domains to get info about is set via constructor.
 * It's executed by @ref exec method with database connection supplied in @ref OperationContext parameter.
 */
class InfoDomainByAdminContactHandle : public Util::Printable<InfoDomainByAdminContactHandle>
{
public:
    /**
     * Info domain constructor with mandatory parameter.
     * @param admin_contact_handle sets domain administrator contact handle into @ref admin_contact_handle_ attribute
     */
    explicit InfoDomainByAdminContactHandle(const std::string& admin_contact_handle);

    /**
     * Sets lock for update.
     * Default, if not set, is lock for share.
     * Sets true to lock flag in @ref lock_ attribute
     * @return operation instance reference to allow method chaining
     */
    InfoDomainByAdminContactHandle& set_lock();

    /**
     * Sets limit on number of returned InfoDomainOutput structures.
     * Filter query ordered by domainid.
     * If not set, there is no limit.
     * Sets  @ref limit_ attribute
     * @return operation instance reference to allow method chaining
     */
    InfoDomainByAdminContactHandle& set_limit(unsigned long long limit);

    /**
     * Executes getting info about the domain.
     * @param ctx contains reference to database and logging interface
     * @param local_timestamp_pg_time_zone_name is postgresql time zone name of the returned data
     * @return info data about domains
     */
    std::vector<InfoDomainOutput> exec(const OperationContext& ctx, const std::string& local_timestamp_pg_time_zone_name = "Europe/Prague");

    /**
     * Dumps state of the instance into the string
     * @return string with description of the instance state
     */
    std::string to_string()const;
private:
    const std::string admin_contact_handle_;/**< administrator contact handle */
    bool lock_;/**< if set to true lock object_registry row for update, if set to false lock for share */
    Optional<unsigned long long> limit_;/**< max number of returned InfoDomainOutput structures */
};

/**
 * Domains info by nsset handle.
 * Nsset handle of domains to get info about is set via constructor.
 * It's executed by @ref exec method with database connection supplied in @ref OperationContext parameter.
 */
class InfoDomainByNssetHandle : public Util::Printable<InfoDomainByNssetHandle>
{
public:
    /**
     * Info domain constructor with mandatory parameter.
     * @param nsset_handle sets domain nsset handle into @ref nsset_handle_ attribute
     */
    explicit InfoDomainByNssetHandle(const std::string& nsset_handle);

    /**
     * Sets lock for update.
     * Default, if not set, is lock for share.
     * Sets true to lock flag in @ref lock_ attribute
     * @return operation instance reference to allow method chaining
     */
    InfoDomainByNssetHandle& set_lock();

    /**
     * Sets limit on number of returned InfoDomainOutput structures.
     * Filter query ordered by domainid.
     * If not set, there is no limit.
     * Sets  @ref limit_ attribute
     * @return operation instance reference to allow method chaining
     */
    InfoDomainByNssetHandle& set_limit(unsigned long long limit);

    /**
     * Executes getting info about domains.
     * @param ctx contains reference to database and logging interface
     * @param local_timestamp_pg_time_zone_name is postgresql time zone name of the returned data
     * @return info data about domains
     */
    std::vector<InfoDomainOutput> exec(const OperationContext& ctx, const std::string& local_timestamp_pg_time_zone_name = "Europe/Prague");

    /**
     * Dumps state of the instance into the string
     * @return string with description of the instance state
     */
    std::string to_string()const;
private:
    const std::string nsset_handle_;/**< nsset handle */
    bool lock_;/**< if set to true lock object_registry row for update, if set to false lock for share */
    Optional<unsigned long long> limit_;/**< max number of returned InfoDomainOutput structures */
};

/**
 * Domains info by keyset handle.
 * Keyset handle of domains to get info about is set via constructor.
 * It's executed by @ref exec method with database connection supplied in @ref OperationContext parameter.
 */
class InfoDomainByKeysetHandle : public Util::Printable<InfoDomainByKeysetHandle>
{
public:
    /**
     * Info domain constructor with mandatory parameter.
     * @param keyset_handle sets domain keyset handle into @ref keyset_handle_ attribute
     */
    InfoDomainByKeysetHandle(const std::string& keyset_handle);

    /**
     * Sets lock for update.
     * Default, if not set, is lock for share.
     * Sets true to lock flag in @ref lock_ attribute
     * @return operation instance reference to allow method chaining
     */
    InfoDomainByKeysetHandle& set_lock();

    /**
     * Sets limit on number of returned InfoDomainOutput structures.
     * Filter query ordered by domainid.
     * If not set, there is no limit.
     * Sets  @ref limit_ attribute
     * @return operation instance reference to allow method chaining
     */
    InfoDomainByKeysetHandle& set_limit(unsigned long long limit);

    /**
     * Executes getting info about domains.
     * @param ctx contains reference to database and logging interface
     * @param local_timestamp_pg_time_zone_name is postgresql time zone name of the returned data
     * @return info data about domains
     */
    std::vector<InfoDomainOutput> exec(const OperationContext& ctx, const std::string& local_timestamp_pg_time_zone_name = "Europe/Prague");

    /**
     * Dumps state of the instance into the string
     * @return string with description of the instance state
     */
    std::string to_string()const;
private:
    const std::string keyset_handle_;/**< keyset handle */
    bool lock_;/**< if set to true lock object_registry row for update, if set to false lock for share */
    Optional<unsigned long long> limit_;/**< max number of returned InfoDomainOutput structures */
};

}//namespace LibFred

#endif//INFO_DOMAIN_HH_E4C6FC6930714E419B82E94BD9F47DC6
